---
layout: post
title:  "深入了解ECNAScript下"
date:   2015-02-1 12:17:06
categories:  JavaScript
excerpt: Javascript作用域链  原型  组合式构造函数  寄生组合式继承  闭包
---

* content
{:toc}

## 作用域链
  
  *作用域链的产生和标识符搜索
  
  我将执行环境统一说成作用域，首先JS只有函数作用域和全局作用域，而在当前作用域会有一个与之关联的变量对象，这个对象包含
  了在本作用域下定义的所有变量，包括参数和函数，全局作用域是最外层的作用域。作用域运行时有一个按顺序链接所有变量对象的
  作用域链参数，作用域链的前端是当前作用域下的变量对象，越外层的作用域的变量对象越靠后直到最外层的全局变量对象。当当前
  函数需要访问变量时，沿着作用域链由前往后搜索标识符，直到找到位置，如果在全局作用域时都没找到返回Undefined，但是搜索
  过程不能逆向，也就是说外层作用域无法访问里层作用域的变量。并且标识符搜索同原型一样，遵从就近原则，如果前面搜索到了，
  就不再往后搜索了。
  
  **注意** 当本作用域函数执行完后本作用域函的变量对象就被销毁，全局作用域的变量是浏览器或页面关闭时销毁
  
  *延长作用域链
  
  两个语句作用域将延长
    1. try-catch语句的catch块
    2. with语句
    对于catch来说是创建了一个包含抛出错误的新对象至作用域链前端，对with来说在作用域链前端添加指定的新对象
    
    
##原型与原型链
  
我尽量用简洁的语言解释原型，上图反而晕
  
*理解原型链的形成
    
1. 每一个函数都有一个属性prototype，该属性指向该函数的原型对象。而每个原型对象都有一个constructor属性，指向
函数本身。 这个函数与对应的原型对象就互相引用了
    
2. 通过函数可以创建一个实例对象，创建的对象都有一个属性[Prototype]（是个指向原型的指针），指向构造函数的原型对象，
    
3. 通过上面，实例对象的[Prototype]属性就指向了构造函数的原型，所以当用一个构造函数创建实例对象并将其赋给一个
函数的原型对象的时候，该函数的原型对象就通过[Prototype]指向了构造函数的原型对象，最后用该函数创建实例对象后，
所创建的实例对象当然指向该函数的原型对象。 
**总结：** 该函数实例对象指向该函数的原型对象，该函数的原型对象又指向父构造函数的原型对象，由此形成原型链。  
**注意：** 其实只需把握一个原则，构造函数创建的实例对象通过[Prototype]都将指向构造函数的原型对象
    
**示例**
    
    var Person = function () { };
        Person.prototype.Say = function () {
            alert("Person say");
        }
        Person.prototype.Salary = 50000;
        var Programmer = function () { };
        Programmer.prototype = new Person();
        Programmer.prototype.WriteCode = function () {
            alert("programmer writes code");
        };
        Programmer.prototype.Salary = 500;
        var p = new Programmer();
        p.Say();          //Person say
        p.WriteCode();    //programmer writes code
        alert(p.Salary);  //500
        
**注意：** 原型链的搜索与作用域链的搜索一样，当前面找到了就往后搜索了，所以p.Salary是500
**注意：**  把新对象赋给原型对象的同时将导致constructor的修改，需要手动把constructor改回
    
*原型的共享
    
通过原型链我们可以想作用域链一个向外逐级搜索属性与方法，由于是引用的性质，所以同样的方法都是来自一个对象上的
方法与属性是共享的而不是副本，类似与变量引用传递的关系。
      
    
    
    
    
  
  
  
