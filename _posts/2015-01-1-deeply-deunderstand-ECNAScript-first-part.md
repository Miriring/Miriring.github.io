---
layout: post
title:  "深入了解ECNAScript上"
date:   2015-01-1 12:06:05
categories:  JavaScript
excerpt: Javascript基本语法 引用传递 作用域 
---

* content
{:toc}

##简介
  主要集中在深入了解上，所以就只列举了ECNAScript里最为重要，难以理解的部分，对于基础知识较少涉及，并且默认都了解过，所以不按顺序讲。
  **我将着重介绍我认为ECNAScrip最重要的概念：**1.引用传递  2.作用域链  3.原型
  
---

##标识符

  * 首先ECNAScript一切都是区分大小写的，并且构造函数的第一个首字母一般大写
  
  * 标识符指的是变量，函数，属性的名字，并且有部分保留字不能使用。 
  
  > **关于这点想强调的是:** 初学者（像我）会分不清什么时候用字符串（带引号），什么时候不带引号（标识符），倒至写参数和引用变量时总傻傻分布清楚。我觉得一个原则，如果不带引号，就会被当作标识符解析，会在作用域链上引用之前设置的变量，函数，而属性也是会往原型链上查找的。如果没有引用的话，只是传一个确定值的情况下就用字符串（不带引号）。
  
##数据类型及传递方式

  * 五种基本类型:Undefined,Null,Boolean,Number,String，一个复杂类型：Object
  
    对于五种基本类型而言是值类型，在变量传递的时候使用的是值传递，可以看作是复制了一分一模一样的副本，该副本与原来的值 完全独立

    **示例:**
  
    <pre><code class="markdown">  
      var a=10;
      b=a; 
      b=5; 
      alert(a) //a==5 
      从上可以看出，a是把一个值得副本给了b，a与b拥有的是彼此独立的10这个值
    </code></pre>
    
    **注意**：
    
    Null类型可以看作一个空对象指针，所以使用 typeof null 会返回oject. 如果初始化引用类型的话用null赋初值
    
  ---
  
  * 对于复杂类型Object，它可以作为构造函数创建出对象，对象是一组数据与函数的集合，可以通过new操作符加构造函数来创建，
  从中我们引申出引用类型。
  
  * 引用类型有：Object,Array,RegExp,Function,基本包装类型（Boolean,Number,String）.
  
  * 首先我们首先来谈引用类型特有的引用传递，也是很多错误的发源地。
  
      引用类型的传递时基于引用的，可以理解成指向一个对象的指针，其中包含了该对象在内存中的地址，变量是通过这个地址和
对象产生了联系，并不是直接存储了该对象。
      
     **示例:**
    
      <pre><code class="markdown">  
        var object1=new Object();
        var object2=boject1;
        object2.num="123"
        alert(object2.num) //a=="123"
        
        var arr=[1,2];
        var arr2=arr;
        arr2[0]=2;
        alert(arr2) //2,2
        从上可以看出引用类型是引用传递的，object2=boject1时是把boject1所指向对象的地址赋给了object2，
        这样object2和object1都指向了同一个对象，所有指向这个对象的变量都会同样反映出它的修改。
      **注意** 其实this也是对本作用域环境变量对象的引用，所以也是引用传递。所以可以将需要的环境变量对象赋给一个
      变量，在其他作用域下引用需要的环境变量对象。
      </code></pre>

      但是函数的参数始终是按值传递的，对可能的误解给出示例：
      
      **示例:**
      
       
            function setName(obj){
              obj.name="Miriring";
              obj=new Object();
              obj.name="csp"
            }
            var person=new Object();
            setName(person);
            alert(person.name);  //Miriring
            
            从上得知obj这个参数其实只是取得了person所存储的指向对象的地址副本，当这个地址被新对象地址覆盖后就
            不再指向原对象了，所以对于obj地址的修改不会影响到person变量，person仍旧指向原对象
            
 ##深入理解对象
   
 * 了解了对象的引用传递后我们来看看对象的创建和本身的特性
   
    **因为函数也可以看做是对象，所以作为最为重要的对象，它的创建方式需要深入了解**
    
    我们直接从函数的角度来看，以下三种实例化方式都是等价的：
        function sum(num1,num2){
          return num1+num2;
          }
        
        var sum=funrion(){
          return num1+num2;
          }
          
        var sum=new Function(){"num1","num2","return num1+num2"};
          
    大多数我们对函数的误解来源于采用第一，二种方式创建函数，而非第三种。因为三者等价，通过第三种我们可以很清
    晰的看出Function实例本身也是用Function这个构造函数产生的对象，所以sum这个函数名其实就是指向对象的引用，
    可以当作保存对象指针的变量看待，声明重名会直接导致覆盖，这也是js没有重载的原因，因为同名函数名都指向的是
    同一个对象。同时函数本身就是用对象的形式使用的，并且通过第三种表达式形式也知函数也可当作值来使用。
  
    **注意** 第一种的函数声明方式和第二种函数表达式有一点区别在于函数声明的函数名会在代码运行之前预解析而函数表达
    式不会，所以可以在声明语句前调用函数，但表达式不行。而且由于预解析，如果函数
        
    * 知道对象创建形式之后我们看看使用操作符new创建对象时究竟发生了什么
      
        var name=new Person();
        
    使用自定义构造函数用new创建对象时经历了三步：
      1. 执行构造函数
      2. 将this指向新创建出的对象
      3. 将对象的prototype属性指向构造函数的prototype对象
          
    通过这样创建出的函数就绑定了构造函数的属性与方法，同时与构造函数的原型对象建立了联系，共享了构造函数原型对象
        
        
  * 当我们观察函数内部时，this与arguments需要特别注意
        
    1. 首先arguments与this都是通过本作用域来获取的，由本作用域的环境变量对象决定，arguments存储的是参数类数组，
    this指向的就是本作用域的环境变量对象，我觉得记住这一点this就不用背那各种情况了。
          
    **注意**  闭包中匿名函数中的this会指向windos全局对象，也是因为this指向的就是本作用域的环境变量对象所致，
    因为闭包匿名函数的环境变量对象具有全局性。
          
    **贴士** 通过arguments指向本作用域对象的特性吗，可以递归时可以方便的将函数调用与函数名解耦,
    arguments.callee就是指向拥有该arguments对象函数的指针
          
            function factorial(num){
              if(num<1){
                return 1;
                }else{
                  return num*arguments.callee(num-1);
                }
            }
          
  * 略微讲下基本包装类型
          
    Boolean,String,Number这个三个构造函数会在对应的基本值类型使用函数或属性的一瞬间创建出对应的对象，使得
    方法和属性得以成功方法，在本语句结束时创建出来的对象就会被立即销毁。这就是基本值类型为什么可以调用方法，
    但只能在本语句期间该方法才存在的原因
          
  * 还有就是常提到的call(),apply(),bind()方法
          
    call()与apply()都是改变this的指向，区别在于call()的第二个参数必须是枚举，apply()第二个参数只接受数组，
    第一个参数都是this指向的对象
    bind()是创建出对象同时改变this指向
          
  * 最后回到对象本身
    对象是函数方法与数据的集合体，这样的统一值得数据的处理更好理解，聚合度更高，但是call(),
    apply()，bind()重要正体现在它通过改变this指向将方法函数与对象解耦，对象可以只存储改对象的数据和基本方法，
    而通过改变this指向，使得各个方法都可以访问到对象，整个数据处理的过程复用性和灵活性都更高
          
          
          
        
        



        
      
        
    
    
    
    
    
    
       
